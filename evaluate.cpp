# include "de.h"
#include <complex>
#include <cmath>
#include <math.h>
using namespace std;

double evaluate(int n, double X[], long *FES, int Num)
{

	double pi = 3.14159265358979;

	int i;
	double mul, sum;
	double c[10];
	//double a[10][4];
	double a[10][6];
	double p1,p2;
	double sum1, sum2;
	double y[30];
	double u[30];
	long double f = 0.0;
	
	double fox[2][25]{
		{ -32, -16, 0, 16, 32, -32, -16, 0, 16, 32, -32, -16, 0, 16, 32, -32, -16, 0, 16, 32, -32, -16, 0, 16, 32 },
		{ -32, -32, -32, -32, -32, -16, -16, -16, -16, -16, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32 }
	};
	double p[4][6];
	double Max;

	(*FES)++;

	for (i = 0; i < n; i++) {
		X[i] = i+1;
	}

	switch (Num) {

	case 0:
		for (i = 0; i < n; i++) {
			f += X[i] * X[i];
		}
		break;
	case 1:
		//printf("TST");
		 mul = 1.0;
		 sum = 0.0;
		for (i = 0; i <=n-1; i++) {
		
			mul = mul*abs(X[i]);
			sum += abs(X[i]);
		}
		f = sum + mul;
	//printf("TST");
		break;

	case 2:
	sum = 0;
		for (i = 0; i < n; i++) {
			for (int j = 0; j <= i; j++) {
				sum += X[j];
			}
			sum = sum*sum;
			f += sum;
			sum = 0.0;
		}
		break;
case 3:

	Max = 0;
		//for (i = 0; i < n; i++) {
		//	if (abs(X[i]) >= MAXPOP)
		//		f = MAXPOP;
		//	else
		//		for (int j = 0; j < i; j++) {
		//			if (abs(X[j]) <= abs(X[j + 1])) {
		//				f = abs(X[j + 1]);
		//			}
		//		}
		//}

		for (i = 0; i < n; i++) {
			if (abs(X[i]) > Max)
				Max = abs(X[i]);

				f = Max;
		}


		break;
case 4:  //Rosenbrock Function

	//for (i = 0; i < n; i++) {
	//	X[i] = 1;
	//}

	//From N-2 to N-1
	f = 0.0;
		for (i = 0; i < n - 1; i++) {

			//For i = 0 To intDim - 2  ' -2: Special case for Rosenbrock
			//	Func = (100.0# * (x(i + 1) - x(i) ^ 2) ^ 2 + (x(i) - 1) ^ 2) + Func
			//	Next i

			f += 100 * pow((X[i+1] - X[i] * X[i]),2) + pow((X[i] - 1),2);
			//f += (100 * pow((X[i + 1] - pow(X[i],2)),2) + pow(X[i] - 1,2) );
			//f += (100 * (X[i + 1] - X[i] * X[i]) *(X[i + 1] - X[i] * X[i]) + (X[i] - 1) *(X[i] - 1));
			//printf("%20.3E", f);
		}
		break;

case 5:
		for (i = 0; i < n; i++) {
			f += pow(floor(X[i] + 0.5), 2);
		}
		break;

case 6:
		for (i = 0; i < n; i++) {
			f += i*X[i] * X[i] * X[i] * X[i];
		}
		f = f + rand() / (RAND_MAX + 1.0);
		break;

case 7:
		//for (i = 0; i < n; i++) {
		//	//f += (-1 * X[i] * sin(sqrt(abs(X[i]))));
		//	sum = abs(X[i]);
		//	sum = sqrt(X[i]);
		//	f = -X[i] * sin(sum) + f;
		//}
	sum1 = 0; f = 0.0;
	for (i = 0; i < n ; i++) {
		//X[i] = 420.968746;
	/*	sum1 = 1.0;
		sum1 = sqrt(fabs(X[i]));
		sum2 = sin(sum1);
		f +=   X[i] * sum2*-1;*/
		f += -(X[i])*(sin(pow(fabs(X[i]),0.5)));
		
	}
//	f = sum1;
	if (f < -12569.5){ f = -1; }
		break;

case 8:
		for (i = 0; i < n; i++) {
			//f+= abs((pow(X[i],2) - 10*(cos(2*pi*X[i])+10)));
			f += (X[i] * X[i] - 10 * cos(2 * pi*X[i]) + 10);
		}
		break;

case 9:
	p1 = 0;
	p2 = 0;
	//for (i = 0; i < n; i++)
	//{
	//	X[i] = 0;
	//}

		for (i = 0; i < n; i++) {
			p1 += X[i] * X[i];
			p2 += cos(2 * pi*X[i]);
		}
		p1 = 20.0 * exp(-(0.2)*sqrt(p1 / n));
		p2 = exp(p2 / n);
		f = 20.0 + exp(1.0) - p1 - p2;
		break;

case 10:
	p1 = 0.0;
	p2 = 1.0;
		for (i = 0; i < n; i++) {
			p1 += X[i] * X[i];
			p2 = p2*cos(X[i] / sqrt(i + 1.0));
		}
		f = p1 / 4000.0 - p2 + 1;
		break;

case 11:
	sum1 = 0;
	sum2 = 0;

		for (i = 0; i < n ; i++) {
			//X[i] = -1;
			y[i] = 1 + 0.25 * (X[i] + 1);
		}

		for (i = 0; i <= n-1 ; i++)
		{
			sum1 += (y[i] - 1) * (y[i] - 1)  * (1 + 10 * (sin(pi * y[i + 1]))*(sin(pi * y[i + 1])));
		}

		//Change from n-1 to n
		for (i = 0; i <n; i++) {
			if (X[i] > 10)
				u[i] = 100 * pow((X[i] - 10), 4);
			else if (X[i] >= -10 && X[i] <= 10)
				u[i] = 0;
			else if (X[i] < -10)
				u[i] = 100 * pow((-X[i] - 10), 4);

			sum2 = u[i] + sum2;
		}

		f = (pi / n) * (10 * (sin(pi * y[1]) * (sin(pi * y[1])) + sum1 + (y[n - 1] - 1)*(y[n - 1] - 1))) + sum2;
		break;

case 12:
	sum1 = 0;
	sum2 = 0;

		for (i = 0; i <= n - 1; i++){
			//X[i] = 1;
			y[i] = 1 + 0.25 * (X[i] + 1);
		}

		for (i = 0; i <= n - 2; i++)
		{
			sum1 = (X[i] - 1) * (X[i] - 1)  * (1 + 10 * (sin(pi * X[i + 1]))*(sin(pi * X[i + 1]))) + sum1;
		}

		for (i = 0; i <= n - 1; i++) {
			if (X[i] > 5)
				u[i] = 100 * pow((X[i] - 5), 4);
			else if (X[i] >= -5 && X[i] <= 5)
				u[i] = 0;
			else if (X[i] < -5)
				u[i] = 100 * pow((-X[i] - 5), 4);

			sum2 = u[i] + sum2;
		}

		f = 0.1 * (sin(3 * pi * X[1]) * (sin(3 * pi * X[1])) + sum1 + (X[n - 1] - 1)*(X[n - 1] - 1)*(1 + sin(2 * pi * X[n - 1])*sin(2 * pi * X[n - 1]))) + sum2;
		break;

case 13:
		sum1 = 0.0;
		sum2 = 0.0;

		//X[0] = -32;
		//X[1] = -32;

		for (int j = 0; j < 25; j++) {

			for (int i = 0; i < 2; i++)
			{
				sum1 += pow((X[i] - fox[i][j]), 6);
			}

			sum1 = sum1 + (j+1);
			sum2 += pow(sum1, -1);
			sum1 = 0;
		}
		f = pow(sum2 + 0.002, -1);
		break;

case 14:
	double aa[11];
	double b[11];
		aa[0] = 0.1957;
		aa[1] = 0.1947;
		aa[2] = 0.1735;
		aa[3] = 0.1600;
		aa[4] = 0.0844;
		aa[5] = 0.0627;
		aa[6] = 0.0456;
		aa[7] = 0.0342;
		aa[8] = 0.0323;
		aa[9] = 0.0235;
		aa[10] = 0.0246;
		b[0] = 4.0;
		b[1] = 2.0;
		b[2] = 1.0;
		b[3] = pow(2,-1);
		b[4] = pow(4, -1);
		b[5] = pow(6, -1);
		b[6] = pow(8, -1);
		b[7] = pow(10, -1);
		b[8] = pow(12, -1);
		b[9] = pow(14, -1);
		b[10] = pow(16, -1);

		
		/*X[0] = 0.1928;
		X[1] = 0.1908;
		X[2] = 0.1231;
		X[3] = 0.1358;*/

		//Ans: 0.000307495249512706

		
		for (i = 0; i < 11; i++) {
	//		sum1 = X[0] * (b[i] * b[i] + b[i] * X[1]);
		//	sum2 = b[i] * b[i] + b[i] * X[2] + X[3];
			f += pow((aa[i] - ((X[0] * (b[i] * b[i] + b[i] * X[1])) / (b[i] * b[i] + b[i] * X[2] + X[3]))), 2);

		}
		/*if (X[0] == 0.1928 &&
			X[1] == 0.1908 &&
			X[2] == 0.1231 &&
			X[3] == 0.1358){
			f = 0.000307495249512706;
		}*/

		
		break;

case 15:
		/*X[0] = -0.08983;
		X[1] = 0.7126;*/
		f = 4 * pow(X[0], 2) - 2.1*pow(X[0], 4) + (1.0 / 3.0)*pow(X[0], 6) + X[0] * X[1] - 4 * pow(X[1], 2) + 4 * pow(X[1], 4);
		break;

case 16:
		/*X[0] = 9.42;
		X[1] = 2.47;*/
		f = (X[1] - (5.1*X[0] * X[0]) / (4 * pi*pi) + 5 * X[0] / pi - 6)*(X[1] - (5.1*X[0] * X[0]) / (4 * pi*pi) + 5 * X[0] / pi - 6) + 10 * (1 - 1 / (8 * pi))*cos(X[0]) + 10;
		break;

case 17:
		/*X[0] = 0;
		X[1] = -1;*/
		f = (1 + (X[0] + X[1] + 1)*(X[0] + X[1] + 1)*(19 - 14 * X[0] + 3 * X[0] * X[0] - 14 * X[1] + 6 * X[0] * X[1] + 3 * X[1] * X[1]))*(30 + (2 * X[0] - 3 * X[1])*(2 * X[0] - 3 * X[1])*(18 - 32 * X[0] + 12 * X[0] * X[0] + 48 * X[1] - 36 * X[0] * X[1] + 27 * X[1] * X[1]));
		break;

case 18:
			a[0][0] = 3, 
			a[0][1] = 10, 
			a[0][2] = 30, 
			a[1][0] = 0.1, 
			a[1][1] = 10, 
			a[1][2] = 35, 
			a[2][0] = 3, 
			a[2][1] = 10, 
			a[2][2] = 30, 
			a[3][0] = 0.1, 
			a[3][1] = 10, 
			a[3][2] = 35;

		p[0][0] = 0.3689, p[0][1] = 0.117, p[0][2] = 0.2673, p[1][0] = 0.4699, p[1][1] = 0.4387, p[1][2] = 0.747, p[2][0] = 0.1091, p[2][1] = 0.8732, p[2][2] = 0.5547, p[3][0] = 0.03815, p[3][1] = 0.5743, p[3][2] = 0.8828;
		c[0] = 1, c[1] = 1.2, c[2] = 3, c[3] = 3.2;
		/*X[0] = 0.114, X[1] = 0.556, X[2] = 0.852;*/
		double sum1;
		for (i = 0; i < 4; i++) {
			sum1 = 0;
			for (int j = 0; j < 3; j++) {
				sum1 += a[i][j] * (X[j] - p[i][j])*(X[j] - p[i][j]);
			}
			sum1 = -sum1;
			f += c[i] * exp(sum1);
		}
		f = -f;
		break;

case 19:
	a[0][0] = 10.0, a[0][1] = 3.0, a[0][2] = 17.0, a[0][3] = 3.5, a[0][4] = 1.7, a[0][5] = 8.0;
	a[1][0] = 0.05, a[1][1] = 10.0, a[1][2] = 17.0, a[1][3] = 0.1, a[1][4] = 8.0, a[1][5] = 14.0;
	a[2][0] = 3.0, a[2][1] = 3.5, a[2][2] = 1.7, a[2][3] = 10.0, a[2][4] = 17.0, a[2][5] = 8.0;
	a[3][0] = 17.0, a[3][1] = 8.0, a[3][2] = 0.05, a[3][3] = 10.0, a[3][4] = 0.1, a[3][5] = 14.0;

	p[0][0] = 0.1312, p[0][1] = 0.1696, p[0][2] = 0.5569, p[0][3] = 0.0124, p[0][4] = 0.8283, p[0][5] = 0.5886;
	p[1][0] = 0.2329, p[1][1] = 0.4135, p[1][2] = 0.8307, p[1][3] = 0.3736, p[1][4] = 0.1004, p[1][5] = 0.9991;
	p[2][0] = 0.2348, p[2][1] = 0.1451, p[2][2] = 0.3522, p[2][3] = 0.2883, p[2][4] = 0.3047, p[2][5] = 0.665;
	p[3][0] = 0.4047, p[3][1] = 0.8828, p[3][2] = 0.8732, p[3][3] = 0.5743, p[3][4] = 0.1091, p[3][5] = 0.0381;

	c[0] = 1.0, c[1] = 1.2, c[2] = 3.0, c[3] = 3.2;
	/*X[0] = 0.201, X[1] = 0.15, X[2] = 0.477, X[3] = 0.275, X[4] = 0.311, X[5] = 0.657;*/
	/*if (X[0] == 0.201 & X[1] == 0.15 & X[2] == 0.477 & X[3] == 0.275 & X[4] == 0.311 & X[5] == 0.657){
		f = -3.32;
		}*/sum1 = 0.0;
	for ( i = 0; i < 4; i++) {
		sum1 = 0;
		for (int j = 0; j < 6; j++) {
			sum1 += a[i][j] * (X[j] - p[i][j])*(X[j] - p[i][j]);
		}
		sum1 = -sum1;
		f += c[i] * exp(sum1);
	}
	f = -f;
	//if (f < -3.32338){ f = -1; }
	break;

case 20:
case 21:
case 22:

	c[0] = 0.1; 
	c[1] = 0.2; 
	c[2] = 0.2; 
	c[3] = 0.4; 
	c[4] = 0.4; 
	c[5] = 0.6; 
	c[6] = 0.3; 
	c[7] = 0.7; 
	c[8] = 0.5; 
	c[9] = 0.5;

	a[0][0] = 4.0; a[0][1] = 4.0; a[0][2] = 4.0; a[0][3] = 4.0;
	a[1][0] = 1.0; a[1][1] = 1.0; a[1][2] = 1.0; a[1][3] = 1.0;
	a[2][0] = 8.0; a[2][1] = 8.0; a[2][2] = 8.0; a[2][3] = 8.0;
	a[3][0] = 6.0; a[3][1] = 6.0; a[3][2] = 6.0; a[3][3] = 6.0;
	a[4][0] = 3.0; a[4][1] = 7.0; a[4][2] = 3.0; a[4][3] = 7.0;
	a[5][0] = 2.0; a[5][1] = 9.0; a[5][2] = 2.0; a[5][3] = 9.0;
	a[6][0] = 5.0; a[6][1] = 5.0; a[6][2] = 3.0; a[6][3] = 3.0;
	a[7][0] = 8.0; a[7][1] = 1.0; a[7][2] = 8.0; a[7][3] = 1.0;
	a[8][0] = 6.0; a[8][1] = 2.0; a[8][2] = 6.0; a[8][3] = 2.0;
	a[9][0] = 7.0; a[9][1] = 3.6; a[9][2] = 7.0; a[9][3] = 3.6;

	if (Num == 20) {
		for (i = 0; i < 5; i++) {
			double sum1 = 0;
			for (int j = 0; j < 4; j++) {
				//X[j] = 4;
				sum1 += (X[j] - a[i][j])*(X[j] - a[i][j]);
			}
			f += 1 / (sum1 + c[i]);
		}
		f = -f;
	}

	if (Num == 21) {
		for (i = 0; i < 7; i++) {
			double sum1 = 0;
			for (int j = 0; j < 4; j++) {
				//X[j] = 4;
				sum1 += (X[j] - a[i][j])*(X[j] - a[i][j]);
			}
			f += 1 / (sum1 + c[i]);
		}
		f = -f;
	}

	if (Num == 22) {

		for (i = 0; i < 10; i++) {
			double sum1 = 0;
			for (int j = 0; j < 4; j++) {
				//X[j] = 4;
				sum1 += (X[j] - a[i][j])*(X[j] - a[i][j]);
			}
			f += 1 / (sum1 + c[i]);
		}
		f = -f;
	}
}//End Case

		return f;
	}
	
	

